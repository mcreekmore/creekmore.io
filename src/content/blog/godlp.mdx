---
title: "godlp: A Beautiful GoLang CLI Experiment"
description: "godlp journey"
date: "February 3, 2024"
---

import Link from "../../components/Link.vue";
import Code from "../../components/Code.vue";
import { createHeading } from "../../components/Heading";

export const components = {
  a: Link,
  code: Code,
  h1: createHeading("h1"),
  h2: createHeading("h2"),
  h3: createHeading("h3"),
};

I've had a fascination with GoLang ever since I heard about it. Especially after 
my first project using it, [triangular arbitrage bot](https://github.com/mcreekmore/arbiter), 
I've been looking for an excuse to use it for something else.

Something I find myself doing often on the comand line at home is using the amazing 
[yt-dlp](https://github.com/yt-dlp/yt-dlp) project to download music and vods from 
YouTube and Soundcloud. yt-dlp is a flexible tool for downloading various content types 
from the web. It's amazing.. Almost too amazing...

The thing is, this project has so many flags and options that I get overwhelmed. After 
I figured out what long command gets me my media exactly as I want, I saved it to a doc 
and whenever I want to dl something else, I awkwardly copy it manually form the doc and 
paste it into my terminal.

Then I take my media file, say a song from soundcloud, and place it into a specific 
folder structure for my Plex instance to pick up correctly in PlexAmp.

> "Couldnt you just make a bash script?"

Well yeah sure, but simplicity isn't the point right now! I want to build something cooler!

## Cobra

You've likely heard of [Cobra](https://cobra.dev/) as it is *the* Go CLI framework. For 
most projects, cobra is an obvious choice. 

I'll use the [cobra-cli](https://github.com/spf13/cobra-cli) to bootstrap the project with 
[viper](https://github.com/spf13/viper) to manage configs later:

```bash
cobra-cli init --author "Matt Creekmore matt@creekmore.io" --viper
```

And we can get started by adding our first command:

```bash
cobra-cli add soundcloud
```

## Binary Dependency Management

If this project is to provide people convenience, we're going to need a way to embed binaries 
into the project so that users don't have to install them seperately as a prerequisite.
With Go 1.16, the native [embed](https://pkg.go.dev/embed@master) directive was added that looks perfect for 
what we need.

Let's create an *embed* package so that we can re-use our binary around our app. 
We'll also need to include *ffmpeg* for any post-processing needs. Our module ends up looking like this:

```go
package embed

import (
	_ "embed"
	"fmt"
	"os"
	"os/exec"
)

//go:embed yt-dlp
var ytDlpBinary []byte

//go:embed ffmpeg
var ffmpegBinary []byte

// ExecuteYtDlp executes yt-dlp from the embedded binary
func ExecuteYtDlp(args []string) {
	// Create a temporary directory
	tempDir, err := os.MkdirTemp("", "yt-dlp-embed")
	if err != nil {
		fmt.Printf("Error creating temporary directory: %v\n", err)
		return
	}
	defer os.RemoveAll(tempDir)

	// Write embedded yt-dlp binary to a temporary file
	ytDlpBinaryPath := tempDir + "/yt-dlp"
	err = os.WriteFile(ytDlpBinaryPath, ytDlpBinary, 0755)
	if err != nil {
		fmt.Printf("Error writing yt-dlp binary to temporary location: %v\n", err)
		return
	}

	// Write embedded ffmpeg binary to a temporary file
	ffmpegBinaryPath := tempDir + "/ffmpeg"
	err = os.WriteFile(ffmpegBinaryPath, ffmpegBinary, 0755)
	if err != nil {
		fmt.Printf("Error writing ffmpeg binary to temporary location: %v\n", err)
		return
	}

	// Append ffmpeg path to args
	args = append(args, "--ffmpeg-location", ffmpegBinaryPath)

	// Execute yt-dlp from the temporary location
	cmd := exec.Command(ytDlpBinaryPath, args...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		fmt.Println(string(output))
		fmt.Printf("Error executing yt-dlp command: %v\n", err)
		return
	}

	fmt.Println(string(output))
}
```

Now we're free to import this anywhere around the project 

```go
embed.ExecuteYtDlp(args)
```
